metavar nat, k ::=
  {{ com natural numbers }}
  {{ lex numeral }}
  {{ coq nat }}
  {{ ocaml int }}
  {{ ocamllex ['0'-'9']+ }}

grammar

num :: 'num_' ::= {{ com num }} {{ pp-suppress }} {{ menhir-start }}
  | k           ::   :: int   {{ com integer }}

value, v  :: 'value_' ::= {{ com value }} {{ pp-suppress }} {{ menhir-start }}
  | k           ::   :: int   {{ com integer }}
  | ( v1 , v2 ) ::   :: tuple {{ com tuple }}

expr, E, e  :: 'expr_' ::= {{ com expression }} {{ menhir-start }}
  | term        ::   :: term  {{ com term }} {{ quotient-remove }} {{ ocaml [[term]] }}
  | E + e       ::   :: add   {{ com addition }}

term, t :: 'expr_' ::= {{ com term }} {{ quotient-with e }}
  | k           ::   :: int   {{ com integer }}
  | t . k       ::   :: proj  {{ com projection }}
  | ( E , e )   ::   :: tuple {{ com tuple }}
  | ! v         ::   :: not   {{ com not }}
  | - num       ::   :: neg   {{ com neg }}
  | ( e )       :: S :: paren {{ icho [[e]] }}

parsing
  expr_add left expr_add

embed {{ menhir %left PLUS }}

% this is what we're testing, to ensure we have minimal support for subrules. we
% should only take the maximal elements from the subrule order: `e` in this case
subrules
  v <:: e
  num <:: v

substitutions
  single term nat :: sub_term_in
